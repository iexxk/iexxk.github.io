---
title: JavaEE之java基础概念
date: 2017-06-19 21:14:28
updated: 2018-01-28 21:41:27categories: JavaEE
tags: [基础,java,面试]
---

## Java基础

### 1 重写（Override）与重载（Overload）

* 重写：**父类与子类之间多态性的一种表现**(继承重写父类的方法)
* 重载：**多态的具体表现形式**（方法名相同，参数不同）

### 2 接口和抽象 

* 接口：

  1. 一个类可以实现多个接口
  2. 一个接口可以有多个方法
  3. 所有方法必须是抽象方法
  4. 接口不能包含成员变量，除了 static 和 final 变量

  ```java
  public interface NameOfInterface
  {
    //接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。
    //接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。
    //接口中的方法都是公有的。
    //任何类型 final, static 字段
    //抽象方法
     public void eat();
     public void travel();
  }
  ```

* 抽象类(abstract)：`public abstract class Test{}`

  1. 抽象类**不能实例化**

* 抽象方法(abstract ): `public abstract double function();`

  1. 含有抽象方法的类必须是抽象类
  2. 实现类必须重写抽象方法
  3. 构造方法(static)不能抽象。

###  3 线程

* 继承Thread
* 实现Runnable

### 4 Java集合框架的基本接口

* collection 接口：最基本的集合接口，一个 Collection 代表一组 Object，Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。
* list接口：List接口是一个有序的Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的小标)来访问List中的元素，而且允许有相同的元素。
* set 接口：Set 具有与 Collection 完全一样的接口，只是行为上不同，Set **不保存重复的元素**。
* map接口：将唯一的键映射到值。

### 5  java中两种异常类型

* error： 错误，由虚拟机生成并抛出，程序对其不做处理
* Exception： 异常的父类，需要程序做出处理
* Runtime Exception： 运行异常，被0除、下标越界等

### 6 Final、finally、finalize

* final： 最终，声明类不可继承、方法不可覆盖、属性不可改变

* finally：是异常处理语句结构的一部分，一定会执行。

  ```java
   		 try {
     			//代码块
           }
           catch (IllegalArgumentException e) {
             
           }
           finally {
            //Java 中的 Finally 关键一般与try一起使用，在程序进入try块之后，无论程序是因为异常而中止或其它方式返回终止的，finally块的内容一定会被执行 。
          }
  ```

* finalize：是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提高垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用。

### 7 序列化（Serializable）

  由于存在于内存中的对象都是暂时的，无法长期驻存，为了把对象的状态保持下来，这时需要把对象写入到磁盘或者其他介质中，这个过程就叫做序列化。实现Serializable接口表示该类可以被序列化。

使用场景：

- 当你想把的内存中的对象状态保存到一个文件中或者数据库中时候
- 当你想用套接字在网络上传送对象的时候
- 当你想通过RMI传输对象的时候

### 8 设计模式

* 单例：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
* 工厂：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
* 模板：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
* 装饰：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
* 代理：为其他对象提供一种代理以控制对这个对象的访问。
* 适配器：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
* 观察者：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

### 9 阻塞队列（BlockingQueue）

如果容器是空的，取东西会阻塞知道里面有东西，如果是满的，放东西会被阻塞，知道有空间放。

#### 参考

[Java就业企业面试问题-Java基础（强烈推荐）](http://bbs.itheima.com/thread-329950-1-1.html?srx)



